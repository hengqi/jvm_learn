# 深入理解JVM

## 类的加载、连接与初始化
   ![](images/jvm01.png 'jvm加载过程')
   
 * Java程序对类的使用方式有两种
   * 主动使用
   * 被动使用
 * 所有的Java虚拟机实现必须在每个类或接口被Java程序 **_首次主动使用_** 时才初始化它们
 * 主动使用（**七种**）
   1. 创建类的实例
   2. 访问某个类或接口的静态变量，或者对该静态变量赋值
   3. 调用类的静态方法
   4. 反射（如Class.forName("com.test.Test")）
   5. 初始化一个类的子类
   6. Java虚拟机启动时被标明为启动类的类（Java Test）
   7. JDK1.7开始提供的动态语言的支持：
    java.lang.invoke.MethodHandle实例的解析结果REF_getStatic, REF_putStatic, REF_invokeStatic句柄对应的类没有初始化，则初始化（了解）
    
   备注：除了上述7种情形，其他使用Java类的方式都被看作时被动使用，不会导致类的初始化
  
 * 除了以上七种情况外，其他使用Java类的方式都被看作时对类的**被动使用**，都不会导致类的**初始化**
## 类的加载
 * 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，
 然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）
 用来封装类在方法区内的数据结构
 * 加载.class文件的方式
   * -从本地系统中直接加载
   * -通过网络下载.class文件
   * -从zip,jar等归档文件中加载.class文件
   * -从专有数据库中提取.class文件
   * -**将java源文件动态编译为.class文件** （动态代理/在web中将jsp转换成servlet进而转换为.class文件）
 * 类的加载的最终产物就是位于内存中的Class对象
 * Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口
 * **有两种类型的类加载器**
   * Java虚拟机自带的加载器
     * 根类加载器（Bootstrap）
     * 扩展类加载器（Extension）
     * 系统（应用）类加载器（System）
        
   * 用户自定义的类加载器
     * java.lang.ClassLoader的子类
     * 用户可以定制类的加载方式
 * 类加载器并不需要等到某个类被“首次主动使用”时再加载它
   * JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失，或者存在错误，
   类加载器必须在程序首次主动使用该类时才报告错误（**LinkageError错误**）
   * 如果这个类一直没有被程序主动使用，那么**类加载器就不会报告错误**
 
 
 
 
 
## 类加载图
![](images/jvm02.png 'jvm加载过程')

 1. 加载：就是把二进制形式的java类型读入java虚拟机中
 2. 链接：   
  2.1.验证:  
  2.2.准备：为类变量分配内存，设置默认值。但是再到达初始化之前，类变量都没有初始化为真正的初始值
  2.3.解析：解析过程就是再类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程
 3. 初始化：为类变量赋予正确的初始值
 
## 类的实例化
![](images/jvm03.png 'jvm加载过程')
  * 为新的对象分配内存
  * 为实例变量赋默认值
  * 为实例变量赋正确的初始值
  * java编译器为它编译的每一个类都至少生成一个实例初始化方法，在Java的class文件中，这个实例初始化方法被称为“<init>”。
  针对源代码中每一个类的构造方法，java编译器都会产生一个<init>方法
  
## 类的验证
 * 类被加载后，就进入连接阶段。连接就是将已经读入到内存的类二进制数据合并到虚拟机的运行时环境中区。
 * 类的验证内容
   * -类文件的机构检查
   * -语义检查
   * -字节码验证
   * -二进制兼容性验证 
   
## 类的初始化
 * 类的初始化步骤
   * 假如这个类还没有被加载和连接，那就先进行加载和连接
   * 假如类存在直接父类，并且这个类还没有被初始化，那就先初始化直接父类
   * 假如类中存在初始化语句，那么就依次执行这些初始化语句
  
## 类的初始化时机
 * 当Java虚拟机初始化一个类的时候，要求它的所有的父类都已经被初始化，但这条规则并不适用于接口
   * 在初始化一个类时，并不会先初始化它所实现的接口
   * 在初始化一个接口时，并不会先初始化它的父接口
   
   因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化
   
 * 调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化
 
## 类加载器
![](images/jvm04.png '类加载器结构图')

## 类加载器的父亲委托机制
 * 在父亲委托机制中，各个加载器按照父子关系形成了‘逻辑上的’树形结构，除了根类加载器之外，其余的类加载器都有且只有一个父加载器
 
 ![](images/jvm05.png '类加载器结构图')
 ![](images/jvm06.png '类加载器结构图')
 
 * 若有一个类加载器能够成功加载Test类，那么这个类加载器被定义为定义类加载器，所有能成功返回Class对象引用的类加载器包括定义类加载器都被称为初始类加载器